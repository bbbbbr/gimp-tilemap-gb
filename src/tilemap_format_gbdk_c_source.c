//
// tilemap_format_gbdk_c_source.c
//

#include <stdio.h>
#include <string.h>

#include "logging.h"

#include "image_info.h"
#include "lib_tilemap.h"
#include "tilemap_io.h"
#include "tilemap_path_ops.h"
#include "tilemap_format_gbdk_c_source.h"


// CGB color range is 0 - 30, so clip RGB in 0 - 255 range to 240
static unsigned char cgb_limit(uint8_t color_val) {
    if (color_val < 240)
        return color_val;
    else
        return 240;
}


int32_t tilemap_format_gbdk_c_source_save(const char * filename, tile_map_data * tile_map, tile_set_data * tile_set, color_data * p_colors) {

    int t,c;
    FILE * file;

    // char path_without_filename[STR_FILENAME_MAX];
    char filename_noext[STR_FILENAME_MAX];

    char filename_tiles_c[STR_FILENAME_MAX];
    char filename_tiles_h[STR_FILENAME_MAX];
    char filename_map_c[STR_FILENAME_MAX];
    char filename_map_h[STR_FILENAME_MAX];
    char varname[STR_FILENAME_MAX];

    uint32_t total_bytes_tiles = 0;

    int pal_index;

    uint16_t tileid_offset = (tile_map->options.map_tileid_offset != OPTION_UNSET) ? tile_map->options.map_tileid_offset : 0;

    log_verbose("Writing to gbdk C source files...\n");

    // Strip extension from filename to
    copy_filename_without_extension(filename_noext, filename);

    snprintf(filename_tiles_c, STR_FILENAME_MAX, "%s_tiles.c", filename_noext);
    snprintf(filename_tiles_h, STR_FILENAME_MAX, "%s_tiles.h", filename_noext);

    snprintf(filename_map_c,   STR_FILENAME_MAX, "%s_map.c", filename_noext);
    snprintf(filename_map_h,   STR_FILENAME_MAX, "%s_map.h", filename_noext);

    // Strip path and extension from filename to
    snprintf(varname,          STR_FILENAME_MAX, "%s", tile_map->options.varname);

    log_verbose("%s\n", filename_tiles_c);
    log_verbose("%s\n", filename_tiles_h);
    log_verbose("%s\n", filename_map_c);
    log_verbose("%s\n", filename_map_h);



    log_verbose("// ==== TILE SET C SOURCE FILE ====\n");
    // ==== TILE SET C SOURCE FILE ====

    // Open the file
    file = fopen(filename_tiles_c, "w");
    if(!file)
        return (false);

    //snprintf(str_header_info, STR_HEADER_MAX, "/*
    fprintf(file, "/*\n\nFilename: %s \n"
     "\n"
     "Tile Source File\n"
     "\n"
     "Info:\n"
     " Form                 : All tiles as one unit\n"
     " Format               : Gameboy 4 color\n"
     " Compression          : None\n"
     " Counter              : None\n"
     " Tile size            : %d x %d\n"
     " Tiles                : 0 to %d\n"
     "\n"
     " Convert to metatiles : No\n"
     "\n"
     " This file was generated by: Gimp Tilemap Plugin\n"
     "\n"
     "*/\n"
     "\n",
    get_filename_from_path(filename_tiles_c),
    tile_set->tile_width,
    tile_set->tile_height,
    tile_set->tile_count);


    // Optional bank number
    if (tile_map->options.bank_num != OPTION_UNSET)
        fprintf(file,
            "/* Bank of tiles */\n"
            "#pragma bank %d\n"
            "const void __at(%d) __bank_%s_tiles;\n"
            "\n",
            tile_map->options.bank_num,
            tile_map->options.bank_num, varname);


    // ==== Add palette as array, but commented out ====
    fprintf(file, "\n"
    "/*\n"
    "// Optional CGB Palette\n"
    "\n"
    "const unsigned int %s_pal_cgb[%d] = {\n  ",
    varname,
    p_colors->color_count);

    for (pal_index = 0; pal_index < p_colors->color_count; pal_index++) {

        // Downshift 3 bits per color component since CGB colors are 5:5:5 bit RGB.
        // Then they're bit-packed into a u16
        fprintf(file, "0x%04X,",
            ( ( cgb_limit(p_colors->pal[(pal_index * 3) + 0]) >> 3)       | // R
             (( cgb_limit(p_colors->pal[(pal_index * 3) + 1]) >> 3) << 5) | // G
             (( cgb_limit(p_colors->pal[(pal_index * 3) + 2]) >> 3) << 10))); // B

        if (pal_index && (((pal_index + 1) % 4) == 0))
            fprintf(file, "  // Palette %d \n  ", ((pal_index + 1) / 4) -1); // Line break between every palette

    }

    // Close the array
    fprintf(file, "};"
    "\n*/\n");


    // ==== For SMS/GG compatibility mode: add a per-tile CGB palette number, but commented out ====
    fprintf(file, "\n"
    "/*\n"
    "// Optional Per-tile CGB Pal number for SMS/GG Compatibility mode\n"
    "\n"
    "const unsigned char %s_tiles_pals[] = {\n",
    varname);

    // Write all the tile set data to a file
    for (t = 0; t < tile_set->tile_count; t++) {
        // Write the tile if it has data
        if (tile_set->tiles[t].p_img_encoded) {
            fprintf(file, " 0x%02X,", tile_set->tiles[t].palette_num);
        }

        if (t && (((t+1) % 8) == 0))
            fprintf(file, "\n"); // Periodic line break
    }

    // Close the array
    fprintf(file, "\n};\n"
    "\n*/\n");



    // ==== Tile array ====
    fprintf(file, "\n"
    "// Start of Tile data\n"
    "\n"
    "const unsigned char %s_tiles[] = {\n",
    varname);

    // Write all the tile set data to a file
    for (t = 0; t < tile_set->tile_count; t++) {
        // Write the tile if it has data
        if (tile_set->tiles[t].p_img_encoded) {

            for (c = 0; c < tile_set->tiles[t].encoded_size_bytes; c++) {
                fprintf(file, " 0x%02X,", tile_set->tiles[t].p_img_encoded[c]);
                total_bytes_tiles++;

                if (c && (((c+1) % 8) == 0))
                    fprintf(file, "\n"); // Periodic line break
            }
            fprintf(file, "\n"); // Line break between every tile
        }
    }

    // Close the array
    fprintf(file, "\n};\n");


    // Close the file
    fclose(file);


    log_verbose("// ==== TILE SET C HEADER FILE ====\n");
    // ==== TILE SET C HEADER FILE ====

    // Open the file
    file = fopen(filename_tiles_h, "w");
    if(!file)
        return (false);

    fprintf(file, "/*\n\nFilename: %s \n"
    "\n"
    "Tile Header File\n"
    "*/\n"
    "\n"
    "#define %s_tiles_count %d\n"
    "#define %s_tiles_bytes %d\n"
    "#define %s_num_pals %d\n"
    "// extern const unsigned int %s_pal_cgb[];\n"
    "// extern const unsigned char %s_tiles_pals[];\n"
    "/* Start of tile array */\n"
    "extern const unsigned char %s_tiles[];\n"
    "\n",
    get_filename_from_path(filename_tiles_h),
    varname,
    tile_set->tile_count,
    varname,
    total_bytes_tiles,
    varname,
    ((p_colors->color_count + 1) / 4),
    varname,
    varname,
    varname);


    // Optional bank number
    if (tile_map->options.bank_num != OPTION_UNSET)
        fprintf(file,
            "/* Bank of tiles */\n"
            "extern const void __bank_%s_tiles;\n"
            "\n", varname);


    // CGB Palette defines as in GBTD export
    fprintf(file, "\n"
    "// CGB Palette\n"
    "\n");

    for (pal_index = 0; pal_index < p_colors->color_count; pal_index++) {

        if (((pal_index % 4) == 0))
            fprintf(file, "// Palette %d \n", (pal_index + 1) / 4); // Line break between every palette

        // Downshift 3 bits per color component since CGB colors are 5:5:5 bit RGB.
        // Then they're bit-packed into a u16
        fprintf(file, "#define %sCGBPal%dc%d 0x%04X\n",
                        varname,
                        (pal_index / 4), // Pal Index
                        (pal_index % 4), // Color index in Pal
             (( cgb_limit(p_colors->pal[(pal_index * 3) + 0]) >> 3)       | // R
             (( cgb_limit(p_colors->pal[(pal_index * 3) + 1]) >> 3) << 5) | // G
             (( cgb_limit(p_colors->pal[(pal_index * 3) + 2]) >> 3) << 10))); // B

    }


    // Close the file
    fclose(file);



    log_verbose("// ==== TILE MAP C SOURCE FILE ====\n");
    // ==== TILE MAP C SOURCE FILE ====

    // Open the file
    file = fopen(filename_map_c, "w");
    if(!file)
        return (false);

    fprintf(file, "/*\n\nFilename: %s \n"
    "\n"
    "Map SOURCE File \n"
    "\n"
    " Info:\n"
    "   Section       :\n"
    "   Bank          : 0\n"
    "   Map size      : %d x %d\n"
    "   Tile offset   : 0\n"
    "\n"
    "This file was generated by: Gimp/Console png2gbtiles\n"
    "*/\n"
    "\n"
    "#define %s_map_width %d\n"
    "#define %s_map_height %d\n"
    "#define %s_map_tiles %d\n"
    "#define %s_map_bytes %d\n"
    "\n",
        get_filename_from_path(filename_map_c),
        tile_map->width_in_tiles,
        tile_map->height_in_tiles,
        varname, tile_map->width_in_tiles,
        varname, tile_map->height_in_tiles,
        varname, tile_map->size,
        varname, tile_map->size);


    // Optional bank number
    if (tile_map->options.bank_num != OPTION_UNSET)
        fprintf(file,
            "/* Bank of map */\n"
            "#pragma bank %d\n"
            "const void __at(%d) __bank_%s_map;\n"
            "\n",
            tile_map->options.bank_num,
            tile_map->options.bank_num, varname);


    fprintf(file, "\n"
      "const unsigned char %s_map[%d] = \n"
      "{\n",varname,
          tile_map->size);

    // Write all the Tile Map data to a file
    for (t = 0; t < tile_map->size; t++) {

        // Write tile id #
        //Add in tile origin offset if requested via options (otherwise origin is zero)
        fprintf(file, " %3d,", tile_map->tile_id_list[t] + tileid_offset);

        if (t && (((t+1) % 16) == 0))
            fprintf(file, "\n"); // Line break every 8 tiles

        if (t && (((t+1) % 64) == 0))
            fprintf(file, "\n"); // Bigger line break every 64 tiles
    }

    // Close the array
    fprintf(file, " };\n");


    fprintf(file,
    "\n\n"
    "const unsigned char %s_map_attr[%d] = \n"
    "{\n",
        varname,
        tile_map->size);

    // Write all the Tile Map data to a file
    for (t = 0; t < tile_map->size; t++) {

        fprintf(file, " %3d,", tile_map->cgb_attrib_list[t]);

        if (t && (((t+1) % 16) == 0))
            fprintf(file, "\n"); // Line break every 8 tiles

        if (t && (((t+1) % 64) == 0))
            fprintf(file, "\n"); // Bigger line break every 64 tiles
    }

    // Close the array
    fprintf(file, " };\n");

    // Close the file
    fclose(file);




    log_verbose("// ==== TILE MAP C HEADER FILE ====\n");
    // ==== TILE MAP C HEADER FILE ====

    // Open the file
    file = fopen(filename_map_h, "w");
    if(!file)
        return (false);

    fprintf(file, "/*\n\nFilename: %s \n"
    "\n"
    "Map Include File\n"
    "\n"
    " Info:\n"
    "   Section       :\n"
    "   Bank          : 0\n"
    "   Map size      : %d x %d\n"
    "   Tile offset   : 0\n"
    "\n"
    "This file was generated by: Gimp/Console png2gbtiles\n"
    "*/\n"
    "\n"
    "#define %s_map_width %d\n"
    "#define %s_map_height %d\n"
    "#define %s_map_tiles %d\n"
    "#define %s_map_bytes %d\n"
    "\n"
    "extern unsigned char %s_map[];\n"
    "extern unsigned char %s_map_attr[];\n"
    "\n",
        get_filename_from_path(filename_map_c),
        tile_map->width_in_tiles,
        tile_map->height_in_tiles,
        varname, tile_map->width_in_tiles,
        varname, tile_map->height_in_tiles,
        varname, tile_map->size,
        varname, tile_map->size,
        varname,
        varname);

    // Optional bank number
    if (tile_map->options.bank_num != OPTION_UNSET)
        fprintf(file,
            "/* Bank of map */\n"
            "extern const void __bank_%s_map;\n"
            "\n", varname);



    // Close the file
    fclose(file);




    return (true);
}

